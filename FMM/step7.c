// Step 7. Sort bodies

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

int getIndex(int iX[2], int level){
  int d, l, index = 0;
  int jX[2] = {iX[0], iX[1]};
  for (l=0; l<level; l++) {
    index += (jX[1] & 1) << (2*l);
    jX[1] >>= 1;
    index += (jX[0] & 1) << (2*l+1);
    jX[0] >>= 1;
  }
  return index;
}

void getIX(int iX[2], int index) {
  int l = 0;
  iX[0] = iX[1] = 0;
  while (index > 0) {
    iX[1] += (index & 1) << l;
    index >>= 1;
    iX[0] += (index & 1) << l;
    index >>= 1;
    l++;
  }
}

void bucketSort(int N, int * index, double * x, double * y) {
  int i, iMax = index[0];
  for (i=1; i<N; i++) {
    if (iMax < index[i]) iMax = index[i];
  }
  iMax++;
  int * bucket = malloc(iMax*sizeof(int));
  double x2[N], y2[N];
  for (i=0; i<iMax; i++) bucket[i] = 0;
  for (i=0; i<N; i++) bucket[index[i]]++;
  for (i=1; i<iMax; i++) bucket[i] += bucket[i-1];
  for (i=N-1; i>=0; i--) {
    bucket[index[i]]--;
    int inew = bucket[index[i]];
    x2[inew] = x[i];
    y2[inew] = y[i];
  }
  for (i=0; i<N; i++) {
    x[i] = x2[i];
    y[i] = y2[i];
  }
  free(bucket);
}

int main() {
  int i, j, N = 100;
  int l, level = 3;
  double x[100] = {0.17280346741136454,0.19115832834401236,0.7345312180072571,0.22560823230249472,0.4183481071265637,0.4047061625817101,0.47374126530527305,0.3257656381156552,0.8708332649320957,0.823947137207495,0.5429211004029263,0.9406693380393317,0.3217285026333436,0.04949142903620796,0.46497223740313964,0.9463026812914828,0.970518265107997,0.3330349673804196,0.8090731528518333,0.45604083652238947,0.11567562359095918,0.9674207796389165,0.46869632661239635,0.9414846321685119,0.08023256929635059,0.5240716834510082,0.6960286062890801,0.7999409478234238,0.5704194349813656,0.9910910773689678,0.7024507167754349,0.26682714693002296,0.707222504801747,0.2576434670296329,0.9191937080396094,0.2913808977769444,0.2469866919609952,0.7688689599797462,0.6872629023953133,0.444311195531766,0.1195744829572638,0.8219112660934099,0.4347967133696745,0.42811329517150454,0.6226077824577202,0.09812096699988604,0.8565672814518892,0.3239637700085993,0.4465774687857481,0.8126202775235158,0.8528033270146841,0.46855650356828904,0.011430166360157368,0.053380606127747754,0.2095451452041761,0.16324917150006235,0.7152996144385662,0.6982752249215572,0.8681078877237871,0.8254643899525447,0.8399587967762273,0.6278184307567404,0.816520892181849,0.6638061944997199,0.9503188681595904,0.2919594574984573,0.5236742729386399,0.45002944570342684,0.966571170068425,0.5295618791588087,0.12450275719737414,0.6865796793168119,0.025638588153187203,0.8493800650472368,0.8804374834268026,0.6039665094740906,0.9427831092651285,0.5412477392245699,0.9689182434945669,0.30198125483096816,0.031892589754185074,0.8441119591345674,0.5045398647767546,0.7014029142381129,0.8111972811031151,0.4720241250308256,0.5228395672741267,0.39258558734412197,0.5985502078985594,0.5384406154501119,0.0729817825447322,0.0398378678673208,0.7514107529286894,0.4922358842589628,0.19898542664629149,0.2553791681856413,0.05958218725901776,0.8169602586890503,0.3632040502778112,0.9316539883403074};
  double y[100] = {0.25013380515409545,0.8105290654776193,0.31725098545584685,0.8872170255712382,0.21869009521813176,0.615867640678987,0.04538620075637667,0.5388987104291129,0.5429111570690346,0.05781336833640838,0.8251503914819508,0.5560895227350965,0.7650894991397028,0.27014455798872017,0.8744569729062712,0.04392368814291636,0.44847625598521235,0.329640361447467,0.9424282484927913,0.552775550332451,0.7214696167260293,0.783250905637877,0.03480724402572177,0.7955021130479697,0.9894799271392315,0.8005242296546681,0.4219479522707924,0.5102991780656028,0.6179692806234449,0.5792095402732351,0.32125265698738803,0.5586919210252812,0.5723098733123593,0.9495476178245952,0.1627835413470109,0.9647535503637135,0.46902723083750286,0.1111736653772144,0.5376416645352932,0.23476448565890673,0.43967920449293063,0.7178688907751729,0.842300925313458,0.5326070226087067,0.4889104444290212,0.7197070126518983,0.24237020468250048,0.46353094765971437,0.42489192391730635,0.996248986542843,0.4922164406268552,0.5769653980403654,0.9598291103158854,0.49954280648760063,0.3635622819821338,0.4060541313342747,0.9228075447754257,0.43525878083496994,0.15120035494952744,0.03333637452576044,0.033120998627662046,0.028803386567355593,0.763714396821058,0.8077786532863226,0.4494698261748855,0.6618061641362114,0.22444665584861467,0.12617960612817514,0.452451044657295,0.7773681363737674,0.44352706948038323,0.4184556338327198,0.2581389673436083,0.21792143960308208,0.9548890924289672,0.838413949876847,0.713444474485892,0.7851761341929943,0.9059653508430493,0.4908373355833979,0.7401002144876803,0.41349256617809516,0.3390437797834398,0.5645584576620254,0.5583700254001736,0.04776686894398552,0.0421315402578486,0.4842761410151576,0.15063217995932243,0.6132140165103924,0.9223203080209729,0.8947755376275118,0.8461834673524026,0.7813877821052738,0.9133729544286112,0.7377271845706209,0.960432744734166,0.43881921424525117,0.7826509384987466,0.6441386836437457};
  double u[N], q[N];

  for (i=0; i<N; i++) {
    u[i] = 0;
    q[i] = 1;
  }
  int iX[2], icell[N];
  int nx = 1 << level;
  for (i=0; i<N; i++) {
    iX[0] = x[i] * nx;
    iX[1] = y[i] * nx;
    icell[i] = getIndex(iX, level);
  }
  bucketSort(N, icell, x, y);
  for (i = 0; i < N; i++) {
    printf("%d %lf %lf\n", icell[i], x[i], y[i]);
  }
  int Nleaf = 0;
  int ic = -1;
  int cells[1 << (2*level)];
  int offset[1 << (2*level)];
  for (i=0; i<N; i++) {
    iX[0] = x[i] * nx;
    iX[1] = y[i] * nx;
    icell[i] = getIndex(iX, level);
    if (ic != icell[i]) {
      // this step does the correspondence between the actual cell number and 
      //  the one that we store for convienvience.
      ic = icell[i];
      cells[Nleaf] = ic;
      offset[Nleaf] = i;
      Nleaf++;
    }
  }

  offset[Nleaf] = N;
  int levelOffset[level+1];
  levelOffset[0] = 0;
  for (l=0; l<level; l++) {
    levelOffset[l+1] = levelOffset[l] + (1 << (2*l));
  }
  int Ncell = nx * nx;
  double M[Ncell+levelOffset[level]], L[Ncell+levelOffset[level]];
  for (i=0; i<Ncell+levelOffset[level]; i++) {
    M[i] = L[i] = 0;
  }
  // P2M
  for (i=0; i<Nleaf; i++) {
    for (j=offset[i]; j<offset[i+1]; j++) {
      M[cells[i]+levelOffset[level]] += q[j];
    }
  }
  // M2M
  for (l=level; l>2; l--) {
    nx = 1 << l;
    Ncell = nx * nx;
    for (i=0; i<Nleaf; i++) {
      j = cells[i];
      M[j/4+levelOffset[l-1]] += M[j+levelOffset[l]];
    }
  }
  printf("\nlevelOffsets: %d %d %d %d\n", levelOffset[0], levelOffset[1], levelOffset[2], levelOffset[3]);
  // M2L
  int jX[2];
  for (l=2; l<=level; l++) {
    nx = 1 << l;
    Ncell = nx * nx;
    for (i=0; i<Ncell; i++) {
      getIX(iX, i);
      printf ("Inside: %d %d\n", iX[0], iX[1]);
      for (j=0; j<Ncell; j++) {
  getIX(jX, j);
  if (abs(iX[0]/2-jX[0]/2) <= 1 && abs(iX[1]/2-jX[1]/2) <= 1) {
    if (abs(iX[0]-jX[0]) > 1 || abs(iX[1]-jX[1]) > 1) {
      double dx = (double)(iX[0] - jX[0]) / nx;
      double dy = (double)(iX[1] - jX[1]) / nx;
      double r = sqrt(dx * dx + dy * dy);
      i = getIndex(iX, level);
      j = getIndex(jX, level);
      printf("Local index: %d\n", i + levelOffset[l]);
      L[i+levelOffset[l]] += M[j+levelOffset[l]] / r;
    }
  }
      }
    }
  }


  // L2L
  for (l=3; l<=level; l++) {
    for (i=0; i<Nleaf; i++) {
      j = cells[i];
      L[j+levelOffset[l]] += L[j/4+levelOffset[l-1]];
    }
  }

  // L2P
  for (i=0; i<Nleaf; i++) {
    for (j=offset[i]; j<offset[i+1]; j++) {
      u[j] += L[cells[i]+levelOffset[level]];
    }
  }

  printf("THIS IS IT!!\n\n\n");
  for (i = 0; i < 100; ++i) {
    printf("u: %lf\n", u[i]);
  }
  // P2P
  int jc;
  for (ic=0; ic<Nleaf; ic++) {
    getIX(iX, cells[ic]);
    for (jc=0; jc<Nleaf; jc++) {
      getIX(jX, cells[jc]);
      if (abs(iX[0]-jX[0]) <= 1 && abs(iX[1]-jX[1]) <= 1) {
  for (i=offset[ic]; i<offset[ic+1]; i++) {
    for (j=offset[jc]; j<offset[jc+1]; j++) {
      double dx = x[i] - x[j];
      double dy = y[i] - y[j];
      double r = sqrt(dx * dx + dy * dy);
      if (r!=0) u[i] += q[j] / r;
    }
  }
      }
    }
  }
  // Check answer
  for (i=0; i<N; i++) {
    double ui = 0;
    for (j=0; j<N; j++) {
      double dx = x[i] - x[j];
      double dy = y[i] - y[j];
      double r = sqrt(dx * dx + dy * dy);
      if (r != 0) ui += q[j] / r;
    }
    printf("%d %lf %lf\n", i, ui, u[i]);
  }
}
